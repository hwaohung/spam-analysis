input {
	file {
		path => "/home/magiclen/下載/spam log/2010/01/*"
		start_position => beginning
		sincedb_path => "/mnt/test/record.db"

		codec => multiline {
			pattern => "^Delivered-To:"
			negate => true
			what => "previous"
		}
	}
} 

filter {

	#Delivered-To
	grok {
		match => { "message" => "^Delivered-To:[ \t]*%{DATA}(?<Delivered-to>[-0-9a-zA-Z.+_]+@[-0-9a-zA-Z.+_]+\.[a-zA-Z]{2,4})"}
	}

	#fetch ip
	if "X-Originating-IP:" in [message] {
		grok {
			match => { "message" => "^X-Originating-IP:[ \t]*%{IP:X-Originating-IP}"}
		}
	} else {
		grok {
			match => [ "message", "(?<X-Originating-IP>(?<![0-9])(?:(?:1[0-2][0-6]|[1-9][1-9]|[0-9])[.](?:25[0-5]|2[0-4][0-9]|[0-1]?[0-9]{1,2})[.](?:25[0-5]|2[0-4][0-9]|[0-1]?[0-9]{1,2})[.](?:25[0-5]|2[0-4][0-9]|[0-1]?[0-9]{1,2})|(?:12[8-9]|1[3-6][0-9]|17[13-9]|18[0-9]|19[01])[.](?:25[0-5]|2[0-4][0-9]|[0-1]?[0-9]{1,2})[.](?:25[0-5]|2[0-4][0-9]|[0-1]?[0-9]{1,2})[.](?:25[0-5]|2[0-4][0-9]|[0-1]?[0-9]{1,2})|172[.](?:[0-9]|1[0-5]|3[2-9]|[4-9][0-9]|25[0-5]|2[0-4][0-9]|1[0-9][0-9])[.](?:25[0-5]|2[0-4][0-9]|[0-1]?[0-9]{1,2})[.](?:25[0-5]|2[0-4][0-9]|[0-1]?[0-9]{1,2})|(?:19[3-9]|2[0-2][0-3])[.](?:25[0-5]|2[0-4][0-9]|[0-1]?[0-9]{1,2})[.](?:25[0-5]|2[0-4][0-9]|[0-1]?[0-9]{1,2})[.](?:25[0-5]|2[0-4][0-9]|[0-1]?[0-9]{1,2})|192[.](?:25[0-5]|2[0-4][0-9]|1[0-57-9][0-9]|16[0-79]|[1-9][0-9]|[0-9])[.](?:25[0-5]|2[0-4][0-9]|[0-1]?[0-9]{1,2})[.](?:25[0-5]|2[0-4][0-9]|[0-1]?[0-9]{1,2}))(?![0-9]))"]
		}
	}

	#Date
	grok {
		match => [ "message", "(?<Date>%{MONTHDAY}[ \t]*%{MONTH}[ \t]*%{YEAR}[ \t]*%{TIME}[ \t]*[+-]\d{4})"]
	}

	# Content-Length
	#if "Content-Length:" in [message] {
	#	grok {
	#		match => [ "message", "^Content-Length:[ \t]*%{POSINT:Content-Length}"]
	#	}
	#}

	#Subject(Maybe multiline)
	if "Subject:" in [message] {
		grok {
			match => [ "message", "^Subject:[ \t]*(?<Subject>((\S+[\S ]*)(\n[\t ]+(\S+[\S ]*))*))"]
			add_tag => [ "has subject" ]
		}
	}
	
	if "has subject" in [tags]{
		#Do nothing
	}else{
		grok {
			match => [ "message", "%{DATA}"]
			add_field => { "Subject" => "No Subject" }
		}
	}

	#Link count
	mutate {
			add_field => {"link_count" => "%{message}"}
	}

	mutate {
			split => ["link_count", "http"]
			add_tag => "split_http"
	}

	if "split_http" in [tags] {
		mutate {
			gsub => ["link_count", "(.|\n)+", "*"] 
		}
	}


	#From
	grok {
		match => [ "message", "^From:[ \t]*%{DATA}(?<From>[-0-9a-zA-Z.+_]+@[-0-9a-zA-Z.+_]+\.[a-zA-Z]{2,4})"]
	}

	#To
	grok {
		match => [ "message", "^To:[ \t]*(?<To>((\S+[\S ]*)(\n[\t ]+(\S+[\S ]*))*))"]
		add_tag => [ "finish" ]
	}
	
	
	#Reply-To
	grok {
		match => [ "message", "^Reply-To:[ \t]*(?<Reply-To>((\S+[\S ]*)(\n[\t ]+(\S+[\S ]*))*))"]
	}
	if "finish" in [tags] {
		#Do nothing
	}else{
		grok {
			match => [ "message", "^Reply-To:[ \t]*(?<To>((\S+[\S ]*)(\n[\t ]+(\S+[\S ]*))*))"]
			add_tag => [ "finish" ]
		}
	}
	
	mutate {
		split => ["Reply-To", ","]
		gsub => ["Reply-To", "(([\w ]*<)|\s|>)", ""]
	}
	
	#Cc
	grok {
		match => [ "message", "^Cc:[ \t]*(?<CC>((\S+[\S ]*)(\n[\t ]+(\S+[\S ]*))*))"]
	}
	if "finish" in [tags] {
		#Do nothing
	}else{
		grok {
			match => [ "message", "^Cc:[ \t]*(?<To>((\S+[\S ]*)(\n[\t ]+(\S+[\S ]*))*))"]
			add_tag => [ "finish" ]
		}
	}
	mutate {
		split => ["CC", ","]
		gsub => ["CC", "(([\w ]*<)|\s|>)", ""]
	}
	
	#Bcc
	grok {
		match => [ "message", "^Bcc:[ \t]*(?<BCC>((\S+[\S ]*)(\n[\t ]+(\S+[\S ]*))*))"]
	}
	if "finish" in [tags] {
		#Do nothing
	}else{
		grok {
			match => [ "message", "^Bcc:[ \t]*(?<To>((\S+[\S ]*)(\n[\t ]+(\S+[\S ]*))*))"]
			add_tag => [ "finish" ]
		}
	}
	mutate {
		split => ["BCC", ","]
		gsub => ["BCC", "(([\w ]*<)|\s|>)", ""]
	}
	
	mutate {
		split => ["To", ","]
		gsub => ["To", "(([\w ]*<)|\s|>)", ""]
	}

	#Content
	#grok {
	#	match => [ "message", "^Content-Type:\s(?<Content-Type>((\S+[\S ]*)(\n[\t ]+(\S+[\S ]*))*))(\n(X|Content)(\-\w+)*:\s[\S ]*)*\n*(?<Content>((%{GREEDYDATA}\s*)*))"]
	#}

	#time format
	date {
		match => ["Date", "d MMM yyyy HH:mm:ss Z"]
		locale => "en"
		target => "@sendTime"
	}

	#convert ip to location info
	geoip {
		source=> "X-Originating-IP"
		database => "/home/magiclen/下載/logstash-1.4.2/vendor/geoip/GeoLiteCity.dat"
		#remove_field => ["[geoip][location]"]
	}
	
	#remove useless fields
	if "finish" in [tags] {
		mutate {
			remove_field => [ "message", "tags", "host", "path", "@version"]
		}
	}
}

output {
	stdout {
		codec => rubydebug
	}
	
	elasticsearch { 
		host => localhost
		codec => json
	}
}
