input {
	file {
		path => "/home/magiclen/bigdata/testlog"
		start_position => beginning
		sincedb_path => "/mnt/test/record.db"

		codec => multiline {
			pattern => "^Delivered-To:"
			negate => true
			what => "previous"
		}
	}
} 

filter {

	#Delivered-To
	grok {
		match => { "message" => "^Delivered-To:\s%{DATA}(?<Delivered-to>[-0-9a-zA-Z.+_]+@[-0-9a-zA-Z.+_]+\.[a-zA-Z]{2,4})"}
	}

	#fetch ip
	if "X-Originating-IP:" in [message] {
		grok {
			match => { "message" => "^X-Originating-IP:\s%{IP:X-Originating-IP}"}
		}
	} else {
		grok {
			match => [ "message", "(?<X-Originating-IP>(?<![0-9])(?:(?:1[0-2][0-6]|[1-9][1-9]|[0-9])[.](?:25[0-5]|2[0-4][0-9]|[0-1]?[0-9]{1,2})[.](?:25[0-5]|2[0-4][0-9]|[0-1]?[0-9]{1,2})[.](?:25[0-5]|2[0-4][0-9]|[0-1]?[0-9]{1,2})|(?:12[8-9]|1[3-6][0-9]|17[13-9]|18[0-9]|19[01])[.](?:25[0-5]|2[0-4][0-9]|[0-1]?[0-9]{1,2})[.](?:25[0-5]|2[0-4][0-9]|[0-1]?[0-9]{1,2})[.](?:25[0-5]|2[0-4][0-9]|[0-1]?[0-9]{1,2})|172[.](?:[0-9]|1[0-5]|3[2-9]|[4-9][0-9]|25[0-5]|2[0-4][0-9]|1[0-9][0-9])[.](?:25[0-5]|2[0-4][0-9]|[0-1]?[0-9]{1,2})[.](?:25[0-5]|2[0-4][0-9]|[0-1]?[0-9]{1,2})|(?:19[3-9]|2[0-2][0-3])[.](?:25[0-5]|2[0-4][0-9]|[0-1]?[0-9]{1,2})[.](?:25[0-5]|2[0-4][0-9]|[0-1]?[0-9]{1,2})[.](?:25[0-5]|2[0-4][0-9]|[0-1]?[0-9]{1,2})|192[.](?:25[0-5]|2[0-4][0-9]|1[0-57-9][0-9]|16[0-79]|[1-9][0-9]|[0-9])[.](?:25[0-5]|2[0-4][0-9]|[0-1]?[0-9]{1,2})[.](?:25[0-5]|2[0-4][0-9]|[0-1]?[0-9]{1,2}))(?![0-9]))"]
		}
	}

	#Date
	if "Date:" in [message] {
		grok {
			match => [ "message", "^Date:\s%{GREEDYDATA},\s(?<Date>%{MONTHDAY}\s%{MONTH}\s%{YEAR}\s%{TIME}\s[+-]\d{4})"]
		}       
	} else {
		# if not exist, find date in [Received]
		grok {
			match => [ "message", "(?<Date>%{MONTHDAY}\s%{MONTH}\s%{YEAR}\s%{TIME}\s[+-]\d{4})"]
		}
	}

	# Content-Length
	if "Content-Length:" in [message] {
		grok {
			match => [ "message", "^Content-Length:\s%{POSINT:Content-Length}"]
		}
	}

	#Cc
	if "Cc:" in [message] {
		grok {
			match => [ "message", "^Cc:\s(?<CC>((\S+[\S ]*)(\n[\t ]+(\S+[\S ]*))*))"]
		}

		mutate {
			split => ["CC", ","]
			gsub => ["CC", "(([\w ]*<)|\s|>)", ""]
		}
	}

	#Subject(Maybe multiline)
	grok {
		match => [ "message", "^Subject:\s(?<Subject>((\S+[\S ]*)(\n[\t ]+(\S+[\S ]*))*))\s"]
	}

	#From
	grok {
		match => [ "message", "^From:\s%{DATA}(?<From>[-0-9a-zA-Z.+_]+@[-0-9a-zA-Z.+_]+\.[a-zA-Z]{2,4})"]
	}

	#To
	grok {
		match => [ "message", "^To:\s(?<To>((\S+[\S ]*)(\n[\t ]+(\S+[\S ]*))*))"]
		add_tag => [ "finish"]
	}
	
	mutate {
		split => ["To", ","]
		gsub => ["To", "(([\w ]*<)|\s|>)", ""]
	}

	#Content
	grok {
		match => [ "message", "^Content-Type:\s(?<Content-Type>((\S+[\S ]*)(\n[\t ]+(\S+[\S ]*))*))(\n(X|Content)(\-\w+)*:\s[\S ]*)*\n*(?<Content>((%{GREEDYDATA}\s*)*))"]
	}

	#time format
	date {
		match => ["Date", "d MMM yyyy HH:mm:ss Z"]
		locale => "en"
	}

	#convert ip to location info
	geoip {
		source=> "X-Originating-IP"
		database =>"./vendor/geoip/GeoLiteCity.dat"
		remove_field => ["[geoip][location]"]
	}
	
	#remove useless fields
	if "finish" in [tags] {
		mutate {
			remove_field => [ "message", "tags", "host", "path", "@version"]
		}
	}
}

output { 
	#stdout {
	#	codec => rubydebug
	#}

	elasticsearch { 
		host => localhost
		codec => json
	}
}
